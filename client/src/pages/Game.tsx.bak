/**
 * ONE PIECE CARD GAME - Battle Board
 * Layout matches pencil-new.pen "OP TCG Battle Board" (JKtu6)
 * Game flow follows official rule_manual.md
 *
 * Structure:
 *  Top:    Opponent Hand Area (overlap cards + stats bar)
 *  Middle: Board Area (Opp Board | Divider | Player Board) + Preview Sidebar
 *  Bottom: Player Hand Area (action buttons + stats bar + hand cards)
 */

import { useEffect, useState, useCallback, useRef } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import {
  useGame, useIsMyTurn, useCanPlayCard, useCanAttack, useIsDefending,
} from '../contexts/GameContext'
import { socketService } from '../services/socket'
import CardComponent, { CardBack } from '../components/Card'
import type { Card, CardSlot } from '../contexts/GameContext'
import './Game.css'

// ============ Phase Prompt Logic (Official Rules) ============
function getPhaseInfo(
  gamePhase: string,
  battleStep: string,
  isMyTurn: boolean,
  isDefending: boolean,
  turnNumber: number,
  pendingAttack: any,
) {
  if (!isMyTurn && !isDefending) {
    return { badge: 'ç­‰å¾…ä¸­', hint: 'å¯¹æ‰‹æ­£åœ¨è¡ŒåŠ¨...' }
  }

  switch (gamePhase) {
    case 'refresh':
      return {
        badge: 'â‘  é‡ç½®é˜¶æ®µ',
        hint: 'æ‰€æœ‰ä¼‘æ¯çŠ¶æ€çš„å¡ç‰Œå°†é‡ç½®ä¸ºæ´»è·ƒçŠ¶æ€ï¼Œé™„åŠ çš„DON!!å¡å½’è¿˜è´¹ç”¨åŒº',
      }
    case 'draw':
      return {
        badge: 'â‘¡ æŠ½å¡é˜¶æ®µ',
        hint: turnNumber === 1 && isMyTurn
          ? 'å…ˆæ‰‹ç¬¬ä¸€å›åˆä¸æŠ½å¡'
          : 'ä»ç‰Œç»„æŠ½1å¼ å¡åŠ å…¥æ‰‹ç‰Œ',
      }
    case 'don':
      return {
        badge: 'â‘¢ DON!!é˜¶æ®µ',
        hint: turnNumber === 1 && isMyTurn
          ? 'å…ˆæ‰‹ç¬¬ä¸€å›åˆåªæ”¾ç½®1å¼ DON!!å¡åˆ°è´¹ç”¨åŒº'
          : 'ä»DON!!ç‰Œç»„æ”¾ç½®2å¼ DON!!å¡åˆ°è´¹ç”¨åŒº',
      }
    case 'main':
      return {
        badge: 'â‘£ ä¸»è¦é˜¶æ®µ',
        hint: 'å¯æ‰§è¡Œ: å‡ºç‰Œ(è§’è‰²/èˆå°/äº‹ä»¶) Â· è´´DON!! Â· å‘åŠ¨æ•ˆæœ Â· æˆ˜æ–—',
      }
    case 'battle':
      if (isDefending) {
        if (battleStep === 'block') {
          return {
            badge: 'âš” æ ¼æŒ¡é˜¶æ®µ',
            hint: 'å¯ä½¿ç”¨æ‹¥æœ‰ã€é˜»æŒ¡è€…ã€‘æ•ˆæœçš„æ´»è·ƒè§’è‰²æ¥æ ¼æŒ¡æ”»å‡»',
          }
        }
        if (battleStep === 'counter') {
          return {
            badge: 'âš” åå‡»é˜¶æ®µ',
            hint: 'å¯ä¸¢å¼ƒæ‰‹ç‰Œä¸­æœ‰åå‡»å€¼çš„è§’è‰²å¡ æˆ– ä½¿ç”¨[Counter]äº‹ä»¶å¡æ¥å¢åŠ åŠ›é‡',
          }
        }
        if (battleStep === 'damage') {
          return { badge: 'âš” ä¼¤å®³ç»“ç®—', hint: 'æ­£åœ¨ç»“ç®—ä¼¤å®³...' }
        }
        return { badge: 'âš” æˆ˜æ–—', hint: 'å¯¹æ‰‹æ­£åœ¨æ”»å‡»' }
      }
      if (pendingAttack) {
        return { badge: 'âš” æˆ˜æ–—ä¸­', hint: 'ç­‰å¾…å¯¹æ‰‹å“åº”...' }
      }
      return {
        badge: 'â‘£ ä¸»è¦é˜¶æ®µ (æˆ˜æ–—)',
        hint: 'é€‰æ‹©æ´»è·ƒçš„è§’è‰²æˆ–é¢†è¢–å‘èµ·æ”»å‡»ï¼Œæˆ–ç»“æŸå›åˆ',
      }
    case 'end':
      return { badge: 'â‘¤ ç»“æŸé˜¶æ®µ', hint: 'å›åˆç»“æŸï¼Œè§¦å‘å›åˆç»“æŸæ•ˆæœ' }
    default:
      return { badge: gamePhase, hint: '' }
  }
}

export default function Game() {
  const { roomId: _roomId } = useParams<{ roomId: string }>()
  const navigate = useNavigate()
  const { state, dispatch } = useGame()

  const isMyTurn = useIsMyTurn()
  const canPlayCard = useCanPlayCard()
  const canAttack = useCanAttack()
  const isDefending = useIsDefending()

  // UI state
  const [hoveredCard, setHoveredCard] = useState<Card | null>(null)
  const [selectedCard, setSelectedCard] = useState<string | null>(null)
  const [targeting, setTargeting] = useState<'none' | 'attack' | 'don'>('none')
  const [donAttachMode, setDonAttachMode] = useState(false)

  // Refs for attack line
  const attackerRef = useRef<HTMLDivElement | null>(null)
  const targetRef = useRef<HTMLDivElement | null>(null)
  const [attackLine, setAttackLine] = useState<{x1:number,y1:number,x2:number,y2:number}|null>(null)

  // ============ Socket Handlers ============
  useEffect(() => {
    const socket = socketService.getSocket()
    if (!socket) { navigate('/lobby'); return }

    const handleGameStart = (data: any) => {
      dispatch({
        type: 'GAME_START',
        player: data.players.find((p: any) => p.isSelf),
        opponent: data.players.find((p: any) => !p.isSelf),
        phase: data.phase,
        turnNumber: data.turnNumber,
        currentTurn: data.currentTurn,
      })
    }
    const handleGameUpdate = (data: any) => {
      dispatch({
        type: 'GAME_UPDATE',
        state: {
          gamePhase: data.phase,
          turnNumber: data.turnNumber,
          currentTurn: data.currentTurn,
          pendingAttack: data.pendingAttack,
          battleStep: data.battleStep,
          winner: data.winner,
        },
        players: data.players,
      })
      if (data.actionLog?.length > 0) {
        data.actionLog.slice(-5).forEach((entry: any) =>
          dispatch({ type: 'ADD_LOG', message: entry.message })
        )
      }
    }
    const handleAttackDeclared = (data: any) => {
      dispatch({
        type: 'SET_PENDING_ATTACK',
        attack: data.pendingAttack,
        battleStep: data.battleStep,
      })
    }
    const handleGameEnd = (data: any) => {
      dispatch({ type: 'SET_WINNER', winner: data.winner })
    }
    const handleError = (data: any) => {
      dispatch({ type: 'SET_ERROR', error: data.message })
    }

    socket.on('game:start', handleGameStart)
    socket.on('game:update', handleGameUpdate)
    socket.on('attack:declared', handleAttackDeclared)
    socket.on('game:end', handleGameEnd)
    socket.on('error', handleError)
    if (!state.player) socket.emit('game:sync')

    return () => {
      socket.off('game:start', handleGameStart)
      socket.off('game:update', handleGameUpdate)
      socket.off('attack:declared', handleAttackDeclared)
      socket.off('game:end', handleGameEnd)
      socket.off('error', handleError)
    }
  }, [dispatch, navigate, state.player])

  // ============ Action handlers ============

  // Play card from hand
  const handleHandCardClick = useCallback((card: Card) => {
    if (!isMyTurn) return
    if (state.gamePhase === 'main') {
      if (card.cardType === 'CHARACTER') {
        const usedSlots = state.player?.characters.length || 0
        if (usedSlots < 5) {
          socketService.playCharacter(card.instanceId, usedSlots)
        } else {
          dispatch({ type: 'SET_ERROR', error: 'è§’è‰²åŒºå·²æ»¡(5å¼ )ï¼Œè¯·å…ˆç§»é™¤ä¸€å¼ è§’è‰²' })
        }
      } else if (card.cardType === 'EVENT') {
        socketService.playEvent(card.instanceId)
      } else if (card.cardType === 'STAGE') {
        socketService.playStage(card.instanceId)
      }
    }
    // Counter step: play counter cards
    if (isDefending && state.battleStep === 'counter') {
      if (card.counter) {
        socketService.playCounter(card.instanceId)
      }
    }
  }, [isMyTurn, state.gamePhase, state.player?.characters.length, isDefending, state.battleStep, dispatch])

  // Select field card for attack
  const handleFieldCardClick = useCallback((cardId: string, isLeader: boolean) => {
    if (donAttachMode) {
      // Attach DON to this card
      socketService.attachDon(cardId)
      setDonAttachMode(false)
      return
    }
    if (!canAttack) return
    // Check the card/leader is active
    if (isLeader) {
      if (state.player?.leader.state !== 'ACTIVE') return
      setSelectedCard('leader')
    } else {
      const slot = state.player?.characters.find(s => s.card.instanceId === cardId)
      if (!slot || slot.state !== 'ACTIVE') return
      setSelectedCard(cardId)
    }
    setTargeting('attack')
  }, [canAttack, donAttachMode, state.player])

  // Choose attack target
  const handleTargetClick = useCallback((targetId: string) => {
    if (targeting !== 'attack' || !selectedCard) return
    const attackerId = selectedCard === 'leader'
      ? state.player!.leader.card.instanceId
      : selectedCard
    socketService.declareAttack(attackerId, targetId)
    setSelectedCard(null)
    setTargeting('none')
    setAttackLine(null)
  }, [targeting, selectedCard, state.player])

  // DON attach mode
  const handleDonClick = useCallback(() => {
    if (!isMyTurn || state.gamePhase !== 'main') return
    setDonAttachMode(prev => !prev)
    setTargeting('none')
    setSelectedCard(null)
  }, [isMyTurn, state.gamePhase])

  // Cancel any targeting
  const cancelAction = useCallback(() => {
    setSelectedCard(null)
    setTargeting('none')
    setDonAttachMode(false)
    setAttackLine(null)
  }, [])

  // Update attack line when hovering target
  const updateAttackLine = useCallback((targetEl: HTMLDivElement | null) => {
    if (!attackerRef.current || !targetEl) { setAttackLine(null); return }
    const aRect = attackerRef.current.getBoundingClientRect()
    const tRect = targetEl.getBoundingClientRect()
    setAttackLine({
      x1: aRect.left + aRect.width / 2,
      y1: aRect.top + aRect.height / 2,
      x2: tRect.left + tRect.width / 2,
      y2: tRect.top + tRect.height / 2,
    })
  }, [])

  // Phase & prompt info
  const phaseInfo = getPhaseInfo(
    state.gamePhase, state.battleStep, isMyTurn,
    !!isDefending, state.turnNumber, state.pendingAttack,
  )

  // Is in main/battle phase where attack is possible
  const inBattlePhase = state.gamePhase === 'battle' || state.gamePhase === 'main'

  // ============ Render helpers ============

  // Render a card slot on the board
  const renderCardSlot = (
    slot: CardSlot | null,
    opts: { isLeader?: boolean; isOpponent?: boolean; zoneClass?: string } = {}
  ) => {
    if (!slot) {
      return <div className="empty-slot" />
    }
    const { isLeader, isOpponent, zoneClass } = opts
    const cardId = slot.card.instanceId
    const isSelected = selectedCard === (isLeader ? 'leader' : cardId)
    const isRested = slot.state === 'RESTED'
    const isTargetable = targeting === 'attack' && isOpponent &&
      (isLeader || isRested) // can attack opp leader or rested characters
    const isAttachable = donAttachMode && !isOpponent

    return (
      <div
        className={[
          'card-slot',
          zoneClass || '',
          isSelected ? 'selected' : '',
          isRested ? 'rested' : '',
          isTargetable ? 'targetable' : '',
          isAttachable ? 'attachable' : '',
        ].filter(Boolean).join(' ')}
        ref={el => {
          if (isSelected && !isOpponent) attackerRef.current = el
          if (isTargetable) targetRef.current = el
        }}
        onClick={() => {
          if (isTargetable) {
            handleTargetClick(isLeader ? 'leader' : cardId)
          } else if (isAttachable) {
            socketService.attachDon(isLeader ? 'leader' : cardId)
            setDonAttachMode(false)
          } else if (!isOpponent && inBattlePhase) {
            handleFieldCardClick(cardId, !!isLeader)
          }
        }}
        onMouseEnter={(e) => {
          setHoveredCard(slot.card)
          if (isTargetable) updateAttackLine(e.currentTarget as HTMLDivElement)
        }}
        onMouseLeave={() => {
          if (isTargetable) setAttackLine(null)
        }}
      >
        <CardComponent card={slot.card} slot={slot} size="small"
          selectable={!isOpponent && inBattlePhase && !isRested}
          selected={isSelected}
          targetable={isTargetable}
        />
        {slot.attachedDon > 0 && (
          <div className="don-badge">DON!! x{slot.attachedDon}</div>
        )}
      </div>
    )
  }

  // ============ RENDER ============
  return (
    <div className="game">
      {/* â•â•â• Phase Prompt Bar (top overlay) â•â•â• */}
      <div className="phase-prompt-bar">
        <span className="phase-badge">{phaseInfo.badge}</span>
        <span className="phase-hint">{phaseInfo.hint}</span>
      </div>

      {/* â•â•â• TOP: Opponent Hand Area â•â•â• */}
      <div className="opp-hand-area">
        <div className="opp-hand-cards">
          {Array.from({ length: state.opponent?.handCount || 0 }).map((_, i) => (
            <div key={i} className="hand-card-wrap">
              <CardBack />
            </div>
          ))}
        </div>
        <div className="opp-stats-bar">
          <span className="name">{state.opponent?.name || 'å¯¹æ‰‹'}</span>
          <div className="stats-right">
            <span className="stat-life">â¤ï¸ {state.opponent?.lifeCount ?? '?'}</span>
            <span className="stat-deck">ğŸ“š {state.opponent?.deckCount ?? '?'}</span>
          </div>
        </div>
      </div>

      {/* â•â•â• MIDDLE: Board + Preview â•â•â• */}
      <div className="middle-section">
        {/* Board Area */}
        <div className="board-area">

          {/* --- Opponent Board (MainArea left, LifeCol right) --- */}
          <div className="opponent-board">
            <div className="main-area">
              {/* CharRow (top for opponent) */}
              <div className="char-row">
                {(state.opponent?.characters || []).map(slot => (
                  <div key={slot.card.instanceId}>
                    {renderCardSlot(slot, { isOpponent: true })}
                  </div>
                ))}
                {(state.opponent?.characters.length || 0) === 0 && (
                  <span style={{color:'#333',fontSize:14,fontWeight:700}}>CHARACTER AREA</span>
                )}
              </div>
              {/* MidRow: Deck | Stage | Leader */}
              <div className="mid-row">
                <div className="zone deck-zone">
                  <span className="zone-label gray">DECK</span>
                  <div className="deck-zone-card">OP</div>
                  <span className="deck-count-label">{state.opponent?.deckCount ?? 0}</span>
                </div>
                <div className="zone stage-zone">
                  <span className="zone-label gray">STAGE</span>
                  {state.opponent?.stage ? (
                    <div className="card-slot" onMouseEnter={() => setHoveredCard(state.opponent!.stage!.card)}>
                      <CardComponent card={state.opponent.stage.card} size="small" />
                    </div>
                  ) : <div className="empty-slot" />}
                </div>
                <div className="zone leader-zone">
                  <span className="zone-label gold">LEADER</span>
                  {state.opponent?.leader &&
                    renderCardSlot(state.opponent.leader, { isLeader: true, isOpponent: true, zoneClass: 'leader-zone' })
                  }
                </div>
              </div>
              {/* BotRow: Trash | Cost Area | DON Deck */}
              <div className="bot-row">
                <div className="zone zone-fixed trash-zone">
                  <span style={{color:'#666',fontSize:9,fontWeight:700,letterSpacing:1}}>TRASH</span>
                  <span className="zone-count">{state.opponent?.trash?.length || 0}</span>
                </div>
                <div className="zone zone-fill cost-zone">
                  <span className="cost-zone-label">COST AREA</span>
                  {/* Opponent DON cards (visual) */}
                  {Array.from({ length: Math.min(state.opponent?.donActive || 0, 10) }).map((_, i) => (
                    <div key={`od-a-${i}`} className="don-card-small">DON!!</div>
                  ))}
                  {Array.from({ length: Math.min(state.opponent?.donRested || 0, 10) }).map((_, i) => (
                    <div key={`od-r-${i}`} className="don-card-small rested">DON!!</div>
                  ))}
                </div>
                <div className="zone zone-fixed">
                  <span style={{color:'#C9A962',fontSize:9,fontWeight:700,letterSpacing:1}}>DON!!</span>
                  <span className="zone-count">{state.opponent?.donDeckCount ?? 0}</span>
                </div>
              </div>
            </div>
            {/* Opponent Life Col (right side) */}
            <div className="life-col">
              <span className="life-label">LIFE</span>
              <div className="life-stack">
                {Array.from({ length: state.opponent?.lifeCount || 0 }).map((_, i) => (
                  <div key={i} className="life-card-wrap"><div className="life-card">OP</div></div>
                ))}
              </div>
            </div>
          </div>

          {/* --- Divider --- */}
          <div className="board-divider" />

          {/* --- Player Board (LifeCol left, MainArea right) --- */}
          <div className="player-board">
            {/* Player Life Col (left side) */}
            <div className="life-col">
              <span className="life-label">LIFE</span>
              <div className="life-stack">
                {Array.from({ length: state.player?.lifeCount || 0 }).map((_, i) => (
                  <div key={i} className="life-card-wrap"><div className="life-card">OP</div></div>
                ))}
              </div>
            </div>
            <div className="main-area">
              {/* CharRow */}
              <div className="char-row">
                {(state.player?.characters || []).map(slot => (
                  <div key={slot.card.instanceId}>
                    {renderCardSlot(slot, { isOpponent: false })}
                  </div>
                ))}
                {(state.player?.characters.length || 0) === 0 && (
                  <span style={{color:'#333',fontSize:14,fontWeight:700}}>CHARACTER AREA</span>
                )}
              </div>
              {/* MidRow: Leader | Stage | Deck */}
              <div className="mid-row">
                <div className="zone leader-zone">
                  <span className="zone-label gold">LEADER</span>
                  {state.player?.leader &&
                    renderCardSlot(state.player.leader, { isLeader: true, isOpponent: false, zoneClass: 'leader-zone' })
                  }
                </div>
                <div className="zone stage-zone">
                  <span className="zone-label gray">STAGE</span>
                  {state.player?.stage ? (
                    <div className="card-slot" onMouseEnter={() => setHoveredCard(state.player!.stage!.card)}>
                      <CardComponent card={state.player.stage.card} size="small" />
                    </div>
                  ) : <div className="empty-slot" />}
                </div>
                <div className="zone deck-zone">
                  <span className="zone-label gray">DECK</span>
                  <div className="deck-zone-card">OP</div>
                  <span className="deck-count-label">{state.player?.deckCount ?? 0}</span>
                </div>
              </div>
              {/* BotRow: DON Deck | Cost Area | Trash */}
              <div className="bot-row">
                <div className="zone zone-fixed">
                  <span style={{color:'#C9A962',fontSize:9,fontWeight:700,letterSpacing:1}}>DON!!</span>
                  <span className="zone-count">{state.player?.donDeckCount ?? 0}</span>
                </div>
                <div className="zone zone-fill cost-zone">
                  <span className="cost-zone-label">COST AREA</span>
                  {Array.from({ length: Math.min(state.player?.donActive || 0, 10) }).map((_, i) => (
                    <div key={`pd-a-${i}`}
                      className={`don-card-small ${donAttachMode ? 'selectable' : ''}`}
                      onClick={donAttachMode ? undefined : handleDonClick}
                    >DON!!</div>
                  ))}
                  {Array.from({ length: Math.min(state.player?.donRested || 0, 10) }).map((_, i) => (
                    <div key={`pd-r-${i}`} className="don-card-small rested">DON!!</div>
                  ))}
                </div>
                <div className="zone zone-fixed trash-zone">
                  <span style={{color:'#666',fontSize:9,fontWeight:700,letterSpacing:1}}>TRASH</span>
                  <span className="zone-count">{state.player?.trash?.length || 0}</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* â•â•â• PREVIEW SIDEBAR (right) â•â•â• */}
        <div className="preview-sidebar">
          <div className="card-preview-area">
            <span className="preview-title">å¡ç‰‡è¯¦æƒ…</span>
            {hoveredCard ? (
              <div className="preview-card-large">
                <div className="prev-top-bar">
                  <span className="prev-cost">{hoveredCard.cost ?? ''}</span>
                  <span className="prev-power">{hoveredCard.power ?? ''}</span>
                  {hoveredCard.counter && <span className="prev-counter">+{hoveredCard.counter}</span>}
                </div>
                <div className="prev-img-area">
                  <img
                    src={`/cards/${hoveredCard.cardNumber}.png`}
                    alt={hoveredCard.name}
                    onError={e => { (e.target as HTMLImageElement).style.display = 'none' }}
                  />
                </div>
                <div className="prev-info-area">
                  <div className="prev-card-name">{hoveredCard.nameCn || hoveredCard.name}</div>
                  <div className="prev-card-trait">
                    {hoveredCard.cardType} Â· {hoveredCard.trait || hoveredCard.color}
                  </div>
                  {hoveredCard.effect && (
                    <div className="prev-effect">{hoveredCard.effect}</div>
                  )}
                </div>
              </div>
            ) : (
              <span className="preview-placeholder">æ‚¬åœå¡ç‰ŒæŸ¥çœ‹è¯¦æƒ…</span>
            )}
          </div>
          {/* Game Log */}
          <div className="game-log">
            {state.actionLog.slice(-20).map((log, i) => (
              <div key={i} className="log-entry">{log.message}</div>
            ))}
          </div>
        </div>
      </div>

      {/* â•â•â• BOTTOM: Player Hand Area â•â•â• */}
      <div className="plr-hand-area">
        {/* Action Buttons */}
        <div className="action-buttons">
          {isMyTurn && state.gamePhase === 'main' && (
            <>
              <button className="btn-battle" onClick={() => socketService.endMainPhase()}>
                è¿›å…¥æˆ˜æ–—
              </button>
              <button className="btn-end-turn" onClick={() => socketService.endTurn()}>
                ç»“æŸå›åˆ
              </button>
              <button className="btn-end-turn" onClick={handleDonClick}>
                {donAttachMode ? 'å–æ¶ˆè´´DON' : 'è´´DON!!'}
              </button>
            </>
          )}
          {isMyTurn && state.gamePhase === 'battle' && !state.pendingAttack && (
            <button className="btn-end-turn" onClick={() => socketService.endTurn()}>
              ç»“æŸå›åˆ
            </button>
          )}
          {(targeting !== 'none' || donAttachMode) && (
            <button className="btn-cancel-action" onClick={cancelAction}>
              âœ• å–æ¶ˆ
            </button>
          )}
        </div>

        {/* Player Stats Bar */}
        <div className="plr-stats-bar">
          <span className="name">{state.player?.name || 'ä½ '} (Player)</span>
          <div className="stats-right">
            <span className="stat-life">â¤ï¸ {state.player?.lifeCount ?? '?'}</span>
            <span className="stat-deck">ğŸ“š {state.player?.deckCount ?? '?'}</span>
          </div>
        </div>

        {/* Player Hand Cards */}
        <div className="plr-hand-cards">
          {(state.player?.hand || []).map((card) => (
            <div key={card.instanceId}
              className={`hand-card-wrap ${canPlayCard ? 'selectable' : ''}`}
              onClick={() => handleHandCardClick(card)}
              onMouseEnter={() => setHoveredCard(card)}
            >
              <CardComponent card={card} size="small"
                selectable={canPlayCard}
              />
            </div>
          ))}
        </div>
      </div>

      {/* â•â•â• ATTACK LINE SVG OVERLAY â•â•â• */}
      {attackLine && (
        <div className="attack-line-overlay">
          <svg>
            <line className="attack-line"
              x1={attackLine.x1} y1={attackLine.y1}
              x2={attackLine.x2} y2={attackLine.y2}
            />
            {/* Arrow head */}
            <circle cx={attackLine.x2} cy={attackLine.y2} r={6}
              fill="#EF5350" opacity={0.8}
            />
          </svg>
        </div>
      )}

      {/* â•â•â• PENDING ATTACK LINE (when attack declared) â•â•â• */}
      {state.pendingAttack && (
        <div className="attack-line-overlay">
          <svg>
            <text x="50%" y="50%" textAnchor="middle" fill="#EF5350" fontSize="16" fontWeight="bold">
              âš” {state.pendingAttack.attackerPower} vs {state.pendingAttack.targetPower}
            </text>
          </svg>
        </div>
      )}

      {/* â•â•â• DEFENDER OVERLAY (Block / Counter) â•â•â• */}
      {isDefending && state.battleStep === 'block' && (
        <div className="defender-overlay">
          <h2>ğŸ›¡ æ ¼æŒ¡é˜¶æ®µ</h2>
          <p>
            å¯¹æ‰‹å‘èµ·æ”»å‡»ï¼åŠ›é‡ {state.pendingAttack?.attackerPower} â†’
            {state.pendingAttack?.isTargetLeader ? 'ä½ çš„é¢†è¢–' : 'ä½ çš„è§’è‰²'} (åŠ›é‡ {state.pendingAttack?.targetPower})
          </p>
          <p>æ˜¯å¦ä½¿ç”¨æ‹¥æœ‰ã€é˜»æŒ¡è€…ã€‘æ•ˆæœçš„è§’è‰²è¿›è¡Œæ ¼æŒ¡ï¼Ÿ</p>
          <div className="def-actions">
            <button onClick={() => socketService.skipBlocker()}>ä¸æ ¼æŒ¡</button>
            {/* Blockers: player characters with Blocker keyword that are active */}
            {(state.player?.characters || [])
              .filter(s => s.state === 'ACTIVE' && s.card.effect?.includes('Blocker'))
              .map(s => (
                <button key={s.card.instanceId} className="primary"
                  onClick={() => socketService.declareBlocker(s.card.instanceId)}
                >
                  ç”¨ {s.card.nameCn || s.card.name} æ ¼æŒ¡
                </button>
              ))
            }
          </div>
        </div>
      )}

      {isDefending && state.battleStep === 'counter' && (
        <div className="defender-overlay">
          <h2>âš¡ åå‡»é˜¶æ®µ</h2>
          <p>
            æ”»å‡»åŠ›é‡ {state.pendingAttack?.attackerPower} vs
            é˜²å¾¡åŠ›é‡ {state.pendingAttack?.targetPower}
          </p>
          <p>
            å¯ä¸¢å¼ƒæ‰‹ç‰Œä¸­æœ‰åå‡»å€¼çš„è§’è‰²å¡å¢åŠ åŠ›é‡ï¼Œæˆ–ä½¿ç”¨[Counter]äº‹ä»¶å¡ã€‚
            ä¹Ÿå¯ä»¥æ¨ªç½®æ´»è·ƒDON!!æ¥ä½¿ç”¨äº‹ä»¶ç‰Œçš„åå‡»æ•ˆæœã€‚
          </p>
          <div className="def-actions">
            <button onClick={() => socketService.skipCounter()}>ä¸åå‡»</button>
            {(state.player?.hand || [])
              .filter(c => c.counter && c.counter > 0)
              .map(c => (
                <button key={c.instanceId} className="primary"
                  onClick={() => socketService.playCounter(c.instanceId)}
                >
                  {c.nameCn || c.name} (+{c.counter})
                </button>
              ))
            }
          </div>
        </div>
      )}

      {/* â•â•â• GAME END â•â•â• */}
      {state.phase === 'ended' && (
        <div className="game-end-overlay">
          <h1>{state.winner === state.player?.id ? 'ğŸ‰ èƒœåˆ©!' : 'ğŸ’€ è´¥åŒ—'}</h1>
          <button onClick={() => navigate('/lobby')}>è¿”å›å¤§å…</button>
        </div>
      )}

      {/* â•â•â• ERROR TOAST â•â•â• */}
      {state.error && (
        <div className="error-toast" onClick={() => dispatch({ type: 'SET_ERROR', error: null })}>
          {state.error}
        </div>
      )}
    </div>
  )
}
